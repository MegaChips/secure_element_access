
/* Standard includes. */
#include <string.h>

/* FreeRTOS inscludes */
#include <FreeRTOS.h>
#include <task.h>

/* CLI */
#include "FreeRTOS_CLI.h"
#include "CLI_task.h"

/* cryptoauthlib library. */
#include "cryptoauthlib.h" 

/* Definitions specific to this project. */
#include "bsp.h"
#include "definitions.h"


/**
 * @brief Stack size for CLI task. 
 */
#define CLI_TASK_STACK_SIZE      (1024)

/**
 * @brief Priority of the CLI task. 
 */
#define CLI_TASK_PRIORITY        (3)  

/**
 * @brief Size of buffer for Strings received by CLI process.
 */
#define SIZE_OF_INPUT_BUFFER     (256)

/**
 * @brief Size of buffer for String generated by CLI process.
 */
#define SIZE_OF_OUTPUT_BUFFER    (1024)


/**
 * @brief This task analyzes the received command and executes it 
 * if it is a registered command. 
 */
void prvCLITask( void *pvParam );

/**
 * @brief Send string to client. 
 */
static void prvCLITask_SendString( uint8_t *pucWriteString );

/**
 * @brief Receive a character from client.  
 * This function waits until valid data is received.  
 */
static void prvCLITask_ReceiveChar( uint8_t *pucReadCharacter );

/* cryptoauthlib configuration. */
extern ATCAIfaceCfg atecc608_0_init_data; 


/*-----------------------------------------------------------*/

BaseType_t xCLITask_Init( void )
{
    BaseType_t xRet = pdFALSE;

    xRet = xTaskCreate( prvCLITask,
                        "CLITask",
                        CLI_TASK_STACK_SIZE,
                        NULL,
                        CLI_TASK_PRIORITY,
                        NULL );
    return xRet;
}

/*-----------------------------------------------------------*/

void prvCLITask( void *pvParam )
{
    uint32_t ulReadIdx = 0UL;
    uint8_t ucReadCharacter = 0;
    BaseType_t xMoreDataToFollow = pdFALSE;
    uint8_t pucInputString[ SIZE_OF_INPUT_BUFFER ];
    uint8_t pucOutputString[ SIZE_OF_OUTPUT_BUFFER ];

    (void)pvParam;

    /* Initialize input buffer. */
    memset( pucInputString, 0, sizeof( pucInputString ) );

    /* Initialize cryptoauthlib library. */
    atcab_init(&atecc608_0_init_data);

    for( ;; )
    {
        prvCLITask_ReceiveChar( &ucReadCharacter );
 
        if( ( ucReadCharacter == '\r' ) || ( (uint8_t)ucReadCharacter == '\n' ) )
        {
            /* Make the output easier to read. */
            prvCLITask_SendString( (uint8_t*)"\r\n" );
 
            /* continue processing until there is no more data to output. */
            do
            {
                xMoreDataToFollow = FreeRTOS_CLIProcessCommand( (char*)pucInputString,
                                                                (char*)pucOutputString,
                                                                SIZE_OF_OUTPUT_BUFFER );
                prvCLITask_SendString( pucOutputString );
            } while( xMoreDataToFollow != pdFALSE );
 
            /* Initialize input buffer and read index. */
            ulReadIdx = 0UL;
            memset( pucInputString, 0, sizeof( pucInputString ) );
        }
        else if( ucReadCharacter == '\b' )
        {
            if( ulReadIdx > 0UL )
            {
                ulReadIdx--;
                pucInputString[ ulReadIdx ] = '\0';
            }
        }
        else
        {
            if( ulReadIdx < ( (uint32_t)SIZE_OF_INPUT_BUFFER - 1UL ))
            {
                pucInputString[ ulReadIdx ] = ucReadCharacter;
                ulReadIdx++;
            }
        }
    }
}

/*-----------------------------------------------------------*/

static void prvCLITask_SendString( uint8_t *pucWriteString )
{
    USART_Write( pucWriteString, (uint32_t)strlen( (const char*)pucWriteString ) );
}

/*-----------------------------------------------------------*/

static void prvCLITask_ReceiveChar( uint8_t *pucReadCharacter )
{
    /* check to see if there is any available data that has not yet been read. */
    while( USART_ReadCountGet() <= 0 )
    {
        vTaskDelay(5 / portTICK_PERIOD_MS);
    }

    USART_Read( pucReadCharacter, 1 );
}